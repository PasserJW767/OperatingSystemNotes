## 2.1 操作系统的启动流程

磁盘：存放OS、Bootloader

BIOS：基本I/O处理系统

1. 在开机时，BIOS会检测各种各样的外设，检测完后才能加载相应的软件，将一个小程序Bootloader从磁盘加载到内存中

2. Bootloader负责将OS从磁盘放到内存中去，从而CPU可以执行操作系统

## 2.2 系统调用、异常与中断的定义

- 系统调用
  
  - 源头：应用程序
  
  - 处理时间：同步或异步。同步指的是发出请求之后等待请求返回；异步是发出请求后去做别的事，操作系统异步返回结果。这指的是应用程序发出请求的那个点是同步的，但返回结果有可能是异步的
  
  - 响应：等待和持续
  
  - 应用程序主动向操作系统发出服务请求（sys_call系统调用）

- 异常
  
  - 源头：应用程序
  
  - 处理时间：同步，比如在除0操作后就会引发异常
  
  - 响应：杀死或重新执行该指令（操作系统做了一些操作使得原本异常的指令能够正常执行）
  
  - 非法指令或者其他坏的指令状态（如内存出错），这时候就需要操作系统去处理

- 中断
  
  - 源头：外设
  
  - 处理时间：异步，因为不知道外设什么时候传入信号
  
  - 响应：持续，对用户应用程序是透明的
  
  - 来自不同硬件设备的计时器和网络的中断

## 2.3 操作系统的必要性

1. 如果程序是直接针对外设进行编程，对于不同的外设就需要编不同的程序。通过操作系统则能够很好地屏蔽这些底层的细节，留下简洁的接口

2. 应用程序直接调用外设，如果出现异常很容易导致整个系统的崩溃，通过操作系统进行访问会更安全。

## 2.4 中断、异常、系统调用的处理过程

包含硬件+软件两方面的处理过程。

对于**中断**而言，产生中断时：

- 硬件
  
  - 将内部、外部事件设置中断标记
  
  - 中断事件ID（软件，即OS可以根据这个中断ID找到对应的处理程序）

- 软件（OS）
  
  - 保存当前处理状态（被打断现场的一些寄存器信息）
  
  - 中断服务程序处理（根据中断事件ID跳转到对应的地址进行执行）
  
  - 处理完中断后，清除中断标记
  
  - 恢复之前保存的处理状态（把之前保存的信息恢复回来）

对于**异常**而言，产生中断时：

- 硬件：与中断类似，会设置中断标记、获得异常编号

- 软件：
  
  - 保存现场
  
  - 异常处理
    
    - 情况1：杀死产生异常的程序（一些程序错误、无法修复的异常只能关闭）
    
    - 情况2：重新执行异常指令（操作系统认为是自身服务不到位时，会尝试修复异常）
  
  - （如果是情况2）恢复现场、

对于**系统调用**而言，例如C语言执行的printf函数，就会调用到操作系统提供的 **write()** 函数，指定在哪个屏幕显示等信息，由操作系统真正地去执行这个命令

## 2.5 用户态与内核态的转变

用户态和内核态的区别：

1. 操作权限不同，用户态低，内核态高；

2. 用户态仅能执行部分指令集，无法访问所有硬件资源，内核态可以执行所有指令集，访问所有硬件资源

区分用户态和内核态的原因：

1. 安全性：操作系统认为应用程序的安全性是不能保证的，所以通过区分用户与内核态最大限度保证操作系统安全

2. 稳定性：用户态程序出现问题不会导致系统出现问题，保证系统稳定

3. 隔离性：使操作系统和用户程序之间有明确边界，利于维护

## 2.6 跨越操作系统边界的开销

中断、异常、系统调用、用户态与内核态转变，实际上都是在跨越操作系统边界，跨越操作系统边界存在以下开销：（执行时间上的开销远超过程序调用）

1. 建立中断/异常/系统调用号与对应服务例程映射关系初始化开销；实际上是需要操作系统在初始化时候就要维护的一张表，是一定的**内存**开销

2. 建立内核堆栈；这个内核堆栈不能与应用程序堆栈混为一谈，实际上就是保存操作系统中断/异常的一些寄存器信息的，还需要恢复，这是一定的**内存**开销

3. 验证参数；操作系统为了保证安全，会对用户程序的调用指令进行检查导致**时间**上的开销

4. 内核态映射到用户态地址空间，更新页面映射权限；这就是一个拷贝过程，拷贝就会导致一定的**时间**开销

5. 内核态独立地址空间
